Hai-OS

**阶段 1 — 启动（Boot & Early init）**

- `kernel/entry.S` 使用 `riscv.h` 的 `PGSIZE` 计算每 hart 启动栈，去掉硬编码 4KB。
- `kernel/kernel.ld` 导出 `__bss_start`/`__bss_end`，便于早期清零和调试。
- `kernel/start.c` 在进入主逻辑前显式清零 BSS，确保初始内存一致。
- `kernel/main.c` 在各 hart 启动提示后追加 “Hai-OS successfully booted.”，便于确认多核已拉起。

**阶段 2 — 内核基础设施与启动序列（Kernel Core）**

- 目标：替换或扩展内核的初始化流程、内核符号、打印、日志、panic 机制。
- 要改的文件：
  - `kernel/main.c`：内核入口 main，初始化子系统调用顺序。
  - `kernel/printf.c`：内核打印实现，可能替换为更安全或更完整的实现（格式化、日志级别）。
  - `kernel/console.c`：控制台/终端抽象。
  - `kernel/uart.c`：串口驱动，启动期打印依赖它。
  - `kernel/log.c`：日志子系统（如果存在），否则新增。

已完成改动（阶段 2）：
- `kernel/main.c` 将启动流程拆分为可读的阶段函数，并在各子系统初始化时输出 Hai-OS 风格日志，便于核对顺序和多核启动状态。
- `kernel/printf.c` / `kernel/defs.h` 增加 `klog()` 与日志级别枚举，输出带 `[Hai-OS LEVEL]` 。

**阶段 3 — 进程与调度（Processes & Scheduler）**

- 目标：实现或替换进程结构、调度算法和上下文切换逻辑。
- 要改的文件：
  - `kernel/proc.c`：进程结构 `proc`、调度器实现、fork/exit/wait 等。
  - `kernel/proc.h`（若存在）或 `kernel/defs.h`：进程数据结构声明。
  - `kernel/swtch.S`：上下文切换汇编实现。
  - `kernel/trap.c`：中断与陷阱处理，和调度器交互（时钟中断驱动调度）。
  - `kernel/param.h`：进程数上限、时间片等参数。
  - `kernel/sysproc.c`、`kernel/syscall.c`、`kernel/syscall.h`：进程相关系统调用接口。

实现要点：
- 决定调度策略（简单的 round-robin、优先级、CFS 风格等），从最简单实现开始。
- 保持 `fork`/`exec`/`wait` 的用户态接口兼容（除非决定破坏兼容），这样现有的 `user/` 程序可以运行。
- 在 `swtch.S` 与 `trap.c` 中实现正确的中断可重入与原子性。

检查点：能够运行 `init` 进程，能 spawn 子进程并进行上下文切换；运行用户 `init` 脚本或 `sh`。

已完成改动（阶段 3）：
- 在 `param.h` 定义时间片/优先级常量，调度策略可配置。
- 在 `proc.h` 为进程新增动态优先级、时间片预算、运行时间和调度次数统计。
- `proc.c` 增加 `proc_tick()` 计时与简单优先级老化，调度器改为“高优先级优先，若同级则运行时间短者优先”，并在每次调度重置时间片、计数调度次数。
- `trap.c` 的定时中断调用 `proc_tick()` 记账后再 `yield()`，保障时间片轮转受控。

**阶段 4 — 虚拟内存与物理内存管理（VM & PM）**

- 目标：实现更稳定或更现代的内存管理（内核分页、物理页分配、内核/用户分离、内存保护）。
- 要改的文件：
  - `kernel/vm.c`：页面表管理（映射/解除映射、页表层次结构）。
  - `kernel/kalloc.c`：物理页分配器（内核页框分配器）。
  - `kernel/memlayout.h`：内存布局常量（内核虚拟基址、设备地址等）。
  - `kernel/vm.h`：内存管理公共接口（若存在）。
  - `kernel/proc.c`：与进程地址空间相关的部分（内存分配、拷贝、释放）。

实现要点：
- 保持用户态内存隔离，正确实现 copy-on-write（如需）或按需分页。
- 如果要支持内核动态内存分配（类似 kmalloc），设计或引入小型分配器。

检查点：用户进程地址空间独立，非法访问产生页面异常并被正确处理；运行内存压力测试（`_stressfs`, `_grind` 等）。

  已完成改动（阶段 4）：
  - `kalloc.c` 引入 Hai-OS 低/临界水位与 OOM 日志，统计总页/空闲页，空闲回升自动清除告警，初始化打印可用容量，并提供 `kalloc_stats()` 供后续查询。
  - `param.h` 增加低/临界水位页数常量，供分配器触发提醒。
  - `vm.c` 的 `kvminit()` 增加 Hai-OS 风格的内核虚拟内存布局日志，便于调试映射范围。
  - `vm.c` 在懒缺页分配失败时输出 OOM 日志（包含 VA 和 pid），方便定位用户态内存压力。

**阶段 5 — 系统调用与用户态 ABI（Syscalls & ABI）**

- 目标：设计你的系统调用集合和调用约定，决定是否兼容 xv6 的 syscall 列表。
- 要改的文件：
  - `kernel/syscall.c`：系统调用分发与处理。
  - `kernel/syscall.h`：系统调用号定义。
  - `user/usys.S`、`user/usys.pl`：用户态系统调用封装。
  - `user/ulib.c`：用户级库函数（例如 `printf`、`open` 等）实现。
  - `kernel/sysproc.c`、`kernel/sysfile.c`：具体 syscall 的内核实现。

实现要点：
- 若改变 ABI，需同时更新 `user/` 下所有依赖的程序或提供兼容层。
- 增加权限检查、参数验证以提升安全性。

检查点：能成功执行常用系统调用：`open/read/write/fork/exec/exit/kill/wait`。

**阶段 6 — 文件系统（FS）与持久化存储**

- 目标：替换或改进文件系统（例如扩展 inode 模型、增加 journaling、增强目录与权限）。
- 要改的文件：
  - `kernel/fs.c`、`kernel/fs.h`：文件系统核心逻辑（inode 管理、目录、链接）。
  - `kernel/file.c`、`kernel/file.h`：文件描述符与文件操作封装。
  - `mkfs/mkfs.c`：创建文件系统映像的工具，若 FS 格式变更必须更新。
  - `kernel/bio.c`：块设备缓冲区接口（块读写缓存）。
  - `kernel/virtio_disk.c`：磁盘设备驱动（对于 virtio），或替换为新的驱动。

实现要点：
- 设计 on-disk 格式时要兼顾可扩展性与向后兼容（可提供转换工具）。
- 在实现新 FS 时，先保证读写基本文件，再实现目录、权限和特殊文件。同步修改 `mkfs` 以生成新的镜像。

检查点：新的 FS 能被 `mkfs` 格式化，并能被内核挂载，用户能读写文件。

**阶段 7 — 设备驱动（Drivers）与外设支持**

- 目标：重构/替换驱动模型（使其支持模块化、动态加载或更严格的隔离）。
- 要改的文件：
  - `kernel/uart.c`：串口驱动，保持早期调试通道。
  - `kernel/virtio_disk.c`、`kernel/virtio.h`：磁盘驱动与接口，如果引入新设备或总线（PCIe），新增文件。
  - `kernel/plic.c`：中断控制器（PLIC）相关代码，管理中断路由与优先级。
  - `kernel/bio.c`：块 I/O 缓冲层，可能需要更高效的缓存策略。

实现要点：
- 设计统一的设备注册与驱动模型（driver probe、attach），便于添加更多设备。
- 为驱动添加调试日志和错误恢复策略。

检查点：设备驱动工作正常（console、磁盘），能在不修改用户程序的前提下完成 I/O 操作。

**阶段 8 — 用户空间工具链与用户程序（Userspace）**

- 目标：决定是否保留原有 `user/` 程序 ABI；改造或替换用户空间库与 init 程序。
- 需要改动的文件：
  - `user/ulib.c`：用户态 C 库实现（syscall 封装、sprintf、字符串操作等）。
  - `user/sh.c`、`user/init.c`：用户 shell 与 init 程序，可能替换为更复杂的 init 系统。
  - `user/*` 下的测试和应用程序：根据新的 syscall/ABI 更新或重新编译。

实现要点：
- 如需扩大用户态能力（线程库、动态链接、ELF loader 升级），先设计好 ABI。
- 如果修改 syscall 参数或行为，同步修改 `user/` 下所有依赖程序或提供兼容层。

检查点：能启动 `init` 并执行常用用户程序（`ls`, `sh`, `cat` 等）。
