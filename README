Hai-OS

**阶段 1 — 启动（Boot & Early init）**

- `kernel/entry.S` 使用 `riscv.h` 的 `PGSIZE` 计算每 hart 启动栈，去掉硬编码 4KB。
- `kernel/kernel.ld` 导出 `__bss_start`/`__bss_end`，便于早期清零和调试。
- `kernel/start.c` 在进入主逻辑前显式清零 BSS，确保初始内存一致。
- `kernel/main.c` 在主核启动时输出版本化的 Hai-OS 启动日志，便于确认多核已拉起。

已完成改动（阶段 1）：
- 启动栈按 `PGSIZE` 对齐，BSS 由 `start.c` 提前清零；主核以 Hai-OS 版本与 `r_time` 指纹打出第一条品牌日志，并同步多核后才放行；`hart2` 负责唯一的 ASCII Logo，强调自有启动体验。

**阶段 2 — 内核基础设施与启动序列（Kernel Core）**

- 目标：替换或扩展内核的初始化流程、内核符号、打印、日志、panic 机制。
- 要改的文件：
  - `kernel/main.c`：内核入口 main，初始化子系统调用顺序。
  - `kernel/printf.c`：内核打印实现，可能替换为更安全或更完整的实现（格式化、日志级别）。
  - `kernel/console.c`：控制台/终端抽象。
  - `kernel/uart.c`：串口驱动，启动期打印依赖它。
  - `kernel/log.c`：日志子系统（如果存在），否则新增。

已完成改动（阶段 2）：
- `kernel/main.c` 将启动流程拆分为可读阶段，并贯穿 Hai-OS 风格日志，核对顺序与多核状态。
- `kernel/printf.c` / `kernel/defs.h`：`klog()` 现带 `[Hai-OS hX tYYY LEVEL]` 前缀（hart 与时间戳），支持运行时日志等级过滤，默认 INFO 但可抑制 DEBUG 噪声。

**阶段 3 — 进程与调度（Processes & Scheduler）**

- 目标：实现或替换进程结构、调度算法和上下文切换逻辑。
- 要改的文件：
  - `kernel/proc.c`：进程结构 `proc`、调度器实现、fork/exit/wait 等。
  - `kernel/proc.h`（若存在）或 `kernel/defs.h`：进程数据结构声明。
  - `kernel/swtch.S`：上下文切换汇编实现。
  - `kernel/trap.c`：中断与陷阱处理，和调度器交互（时钟中断驱动调度）。
  - `kernel/param.h`：进程数上限、时间片等参数。
  - `kernel/sysproc.c`、`kernel/syscall.c`、`kernel/syscall.h`：进程相关系统调用接口。

实现要点：
- 决定调度策略（简单的 round-robin、优先级、CFS 风格等），从最简单实现开始。
- 保持 `fork`/`exec`/`wait` 的用户态接口兼容（除非决定破坏兼容），这样现有的 `user/` 程序可以运行。
- 在 `swtch.S` 与 `trap.c` 中实现正确的中断可重入与原子性。

检查点：能够运行 `init` 进程，能 spawn 子进程并进行上下文切换；运行用户 `init` 脚本或 `sh`。

已完成改动（阶段 3）：
- 在 `param.h` 定义多档时间片（高优先级短片、低优先级长片），调度策略可配置。
- 在 `proc.h` 为进程新增动态优先级、时间片预算、运行时间、调度次数与 RUNNABLE 时间戳。
- `proc.c`：
  - `proc_tick()` 针对 CPU hog 做优先级下调并按档位重置时间片；
  - 交互型/IO 进程在 `wakeup()` 时被自动升优先级并重置时间片；
  - `yield()` 自愿让出且未用完时间片时奖励升优先级；
  - 调度器按优先级选择，同级挑等待最久者，减少饥饿。
- `trap.c` 的定时中断继续先记账再 `yield()`。

**阶段 4 — 虚拟内存与物理内存管理（VM & PM）**

- 目标：实现更稳定或更现代的内存管理（内核分页、物理页分配、内核/用户分离、内存保护）。
- 要改的文件：
  - `kernel/vm.c`：页面表管理（映射/解除映射、页表层次结构）。
  - `kernel/kalloc.c`：物理页分配器（内核页框分配器）。
  - `kernel/memlayout.h`：内存布局常量（内核虚拟基址、设备地址等）。
  - `kernel/vm.h`：内存管理公共接口（若存在）。
  - `kernel/proc.c`：与进程地址空间相关的部分（内存分配、拷贝、释放）。

实现要点：
- 保持用户态内存隔离，正确实现 copy-on-write（如需）或按需分页。
- 如果要支持内核动态内存分配（类似 kmalloc），设计或引入小型分配器。

检查点：用户进程地址空间独立，非法访问产生页面异常并被正确处理；运行内存压力测试（`_stressfs`, `_grind` 等）。

已完成改动（阶段 4）：
- `kalloc.c` 引入 Hai-OS 低/临界水位与 OOM 日志，统计总页/空闲页，空闲回升自动清除告警，初始化打印可用容量，并提供 `kalloc_stats()` 供后续查询。
- `kalloc.c` 统计接口加锁，并新增 `kalloc_pressure_percent()` 便于策略/调度读取内存压力。
- `param.h` 增加低/临界水位页数常量，供分配器触发提醒。
- `vm.c` 的 `kvminit()` 增加 Hai-OS 风格的内核虚拟内存布局日志，便于调试映射范围。
- `vm.c` 在懒缺页分配失败时输出 OOM 日志（包含 VA 和 pid），成功时为进程累加缺页计数 `page_faults`，方便统计用户态内存压力。

**阶段 5 — 系统调用与用户态 ABI（Syscalls & ABI）**

- 目标：设计你的系统调用集合和调用约定，决定是否兼容 xv6 的 syscall 列表。
- 要改的文件：
  - `kernel/syscall.c`：系统调用分发与处理。
  - `kernel/syscall.h`：系统调用号定义。
  - `user/usys.S`、`user/usys.pl`：用户态系统调用封装。
  - `user/ulib.c`：用户级库函数（例如 `printf`、`open` 等）实现。
  - `kernel/sysproc.c`、`kernel/sysfile.c`：具体 syscall 的内核实现。

实现要点：
- 若改变 ABI，需同时更新 `user/` 下所有依赖的程序或提供兼容层。
- 增加权限检查、参数验证以提升安全性。

检查点：能成功执行常用系统调用：`open/read/write/fork/exec/exit/kill/wait`。

已完成改动（阶段 5）：
- 新增 Hai-OS 专属观测与调度控制 ABI：
  - `sysinfo(struct hai_sysinfo*)` 返回物理页总/空闲、内存压力、tick、进程数量与当前日志等级。
  - `setpriority(pid, prio)` / `getpriority(pid)` 允许用户态调节/查询进程动态优先级（0-3），内核重置时间片并刷新调度戳。
  - `klogctl(level)` 运行时切换内核日志等级（INFO/WARN/ERROR/DEBUG），即时生效。
- 共享头 `kernel/hai_sysinfo.h` 暴露 ABI 结构体，用户库 `ulib.c`/`user.h` 提供封装。
- 新用户程序 `sysinfo`：展示 Hai-OS sysinfo，支持 `klog <lvl>` 动态改日志等级，`setprio <pid> <prio>` 在线调节进程优先级，体现与原始 xv6 的诊断/调度差异化。

**阶段 6 — 文件系统（FS）与持久化存储**（第一步：可观测性与接口脚手架，后续再做结构大改）

- 设计目标（Hai-OS 版 FS）
  - 日志化 + 校验：引入写前日志（journaling）覆盖 inode/dirent/bitmap，数据块做 4KB 粒度校验和，防止 silent corruption。
  - 目录加速：目录页采用哈希分桶或 B+Tree 索引，支持高并发 `lookup/readdir`；长文件名与子目录深度不再受 xv6 限制。
  - 权限/配额：在 inode 增加简易 ACL 与每目录/每用户配额（硬/软限额），提供 `quotactl` 风格接口。
  - 空间管理：bitmap 升级为 extent/段式分配器，减少碎片并为大文件提供顺序 IO；`mkfs` 支持可配置块大小与可选预留区。
  - 调试与遥测：新增 `statfs`/`fsinfo` 接口，暴露日志区参数、I/O 计数、块/索引使用概况与校验错误计数（占位），便于 sysinfo/用户工具读取。

- 预期改动面（核心文件）
  - `kernel/fs.c`/`fs.h`：重写 inode on-disk 布局（增加 ACL、校验和、extent 头），目录项改为哈希/树结构，补充 statfs 接口。
  - `kernel/file.c`/`file.h`：扩展 `fstat` 以暴露校验状态、extent 信息；新增 `quotactl`、`fsinfo` 相关分发。
  - `kernel/bio.c`：页级校验计数（首阶段），后续增加校验和与失败日志；bio 缓存支持脏块批量刷写与写序列号（规划）。
  - `kernel/log.c`：从简单 redo 日志升级为分段日志，支持元数据 + 可选数据 journaling，崩溃后快速重放。
  - `mkfs/mkfs.c`：能生成新 on-disk 格式（可选块大小、预留区、初始 ACL/quota），并输出格式版本号供内核校验。

- 兼容性与工具
  - 升级后镜像格式将不兼容原 xv6，需使用 Hai-OS `mkfs` 重建；可选提供只读兼容层或转换工具。
  - 自带用户工具：`fsinfo`（已实现：打印 statfs/I/O/日志区参数）；后续：`fsck`（校验和/日志检查）、`quota`（查询/设置配额）。

已完成（阶段 6 第一波）
- 新增 `statfs` 系统调用与 `fsinfo` 用户程序，展示：总块/数据块/日志区参数、块/索引使用、I/O 次数与校验错误占位。
- `bio` 暴露 `io_reads/io_writes/checksum_errors` 计数（首阶段）。
- `fs.c` 提供 `fs_statfs()`，扫描位图/索引以统计使用与空闲。

已完成（阶段 6 巨大差异版，FSv2 Extent 版）
- 彻底替换磁盘布局：超级块改为 Hai-OS FSv2（魔数 `HAIF`，版本号、块大小指数、校验算法占位）；inode 改为 6 段 extent + 校验预留位，去掉 NDIRECT/NINDIRECT（设为 0）并重新定义 MAXFILE。
- `kernel/fs.c`：`bmap`/`itrunc`/`iupdate`/`ilock` 全部按 extent 路径工作，追加与映射统一走 extent 分配器；`fs_statfs` 输出 FS 版本、块大小、校验算法等。
- `mkfs/mkfs.c`：生成 FSv2 超级块；`iappend` 重写为 extent 追加并维护连续块；构建出的 `fs.img` 与原 xv6 不兼容。
- 用户态 `fsinfo` 同步展示 FS 版本、块大小和校验算法，方便确认新格式已生效。
- 校验：引入 Adler-32 文件级校验，写入后自动重算并写入 inode；全文件读会核验并将失败计入 `bio_checksum_errors`，`statfs`/`fsinfo` 报告并标记 has_checksum=1。
- 目录索引：inode 内置 DIRCACHE（哈希缓存）捕获最多 256 个 dirent，`dirlookup` 优先命中缓存，写目录时自动失效。
- `mkfs` 生成 checksum_alg=Adler32 的超级块并为所有文件/目录预计算校验，保证新镜像开机即可信。
- FSv2 增强：超级块新增 data_csum/log_segments/quota 预留字段，`statfs/fsinfo` 可见；新增 syscall `fverify(path)` 重新计算并校验单文件校验和；用户态 `fverify` 命令批量校验文件。

**阶段 7 — 设备驱动（Drivers）与外设支持**

- 目标：重构/替换驱动模型（使其支持模块化、动态加载或更严格的隔离）。
- 要改的文件：
  - `kernel/uart.c`：串口驱动，保持早期调试通道。
  - `kernel/virtio_disk.c`、`kernel/virtio.h`：磁盘驱动与接口，如果引入新设备或总线（PCIe），新增文件。
  - `kernel/plic.c`：中断控制器（PLIC）相关代码，管理中断路由与优先级。
  - `kernel/bio.c`：块 I/O 缓冲层，可能需要更高效的缓存策略。

实现要点：
- 设计统一的设备注册与驱动模型（driver probe、attach），便于添加更多设备。
- 为驱动添加调试日志和错误恢复策略。

检查点：设备驱动工作正常（console、磁盘），能在不修改用户程序的前提下完成 I/O 操作。

已完成改动（阶段 7）
- 新增 `kernel/driver.c` 驱动框架：支持注册/初始化/按 hart 初始化，带统一 klog 事件；内置注册 PLIC 与 virtio-blk 驱动。
- `main.c` 改为通过驱动框架初始化 PLIC/virtio，并在次级 hart 路径调用 `hart_init_drivers()`，形成统一的 per-hart 初始化入口。
- `Makefile` 添加 `driver.o`，`defs.h` 暴露驱动框架接口，便于后续新增设备按统一入口接入。

**阶段 8 — 用户空间工具链与用户程序（Userspace）**

- 目标：决定是否保留原有 `user/` 程序 ABI；改造或替换用户空间库与 init 程序。
- 需要改动的文件：
  - `user/ulib.c`：用户态 C 库实现（syscall 封装、sprintf、字符串操作等）。
  - `user/sh.c`、`user/init.c`：用户 shell 与 init 程序，可能替换为更复杂的 init 系统。
  - `user/*` 下的测试和应用程序：根据新的 syscall/ABI 更新或重新编译。

实现要点：
- 如需扩大用户态能力（线程库、动态链接、ELF loader 升级），先设计好 ABI。
- 如果修改 syscall 参数或行为，同步修改 `user/` 下所有依赖程序或提供兼容层。

检查点：能启动 `init` 并执行常用用户程序（`ls`, `sh`, `cat` 等）。

已完成改动（阶段 8）
- `init` 在启动 shell 前输出 Hai-OS 观测面板：`sysinfo` + `statfs`（FS 版本、块大小、校验特性、空间与 inode 使用），强调与原版 xv6 不同的可见性。
- `sh` 提供 Hai 风格动态提示符 `[hai mem=XX% procs=YY lvl=Z]$`，实时反映内核内存压力/进程数/日志等级；新增内置命令：`sysinfo`（打印物理页与压力）、`fsinfo`（打印 FS v2 元数据与使用率）、`klog <lvl>`（调整内核日志等级）、`prio <pid> <level>`（用户态调节进程优先级）。
- Shell 继续兼容管道/重定向/后台等语法，但默认提示与内置能力已与原版 xv6 明显区别。

FS 强化：目录索引（哈希/B+树）、数据块校验表、日志分段化/数据 journaling 开关、配额占位与 fsck-lite。
调度/内存：CFS/MLFQ 调度、COW fork、slab 小对象分配器、guard pages。
用户态/ABI：新增 spawn 系统调用（fork+exec 结合）、schedinfo/vmstat/devinfo 查询（sysctl 风格），eventfd/timerfd/dmesg 暂为占位；内置工具 top/ps/devinfo/dmesg 用于观测。
驱动框架增强：devinfo 注册表、virtio 队列统计、UART 环缓/流控占位
